/* Generated by Edge Impulse
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
// Generated on: 29.03.2021 14:52:01

#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/kernels/micro_ops.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#endif

namespace {

constexpr int kTensorArenaSize = 1600;

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};
enum used_operators_e {
  OP_RESHAPE, OP_CONV_2D, OP_ADD, OP_MAX_POOL_2D, OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};
struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  TfLiteType type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};
struct NodeInfo_t { // subset of TfLiteNode used for initialization from constant memory
  struct TfLiteIntArray* inputs;
  struct TfLiteIntArray* outputs;
  void* builtin_data;
  used_operators_e used_op_index;
};

TfLiteContext ctx{};
TfLiteTensor tflTensors[31];
TfLiteRegistration registrations[OP_LAST];
TfLiteNode tflNodes[15];

const TfArray<2, int> tensor_dimension0 = { 2, { 1,30 } };
const ALIGN(8) int32_t tensor_data1[2] = { -1, 24, };
const TfArray<1, int> tensor_dimension1 = { 1, { 2 } };
const ALIGN(8) float tensor_data2[16] = { -0.005601758137345314, -0.038648907095193863, 0, -0.044913638383150101, 0.13847832381725311, -0.040506415069103241, 0.14773841202259064, 0, 0.17974200844764709, -0.014494405128061771, 0.18687827885150909, -0.040968973189592361, -0.028081484138965607, 0, -0.027137964963912964, -0.029630472883582115, };
const TfArray<1, int> tensor_dimension2 = { 1, { 16 } };
const ALIGN(8) float tensor_data3[8] = { -0.036362398415803909, 0.017588585615158081, 0.02628757432103157, 0.11796184629201889, -0.015600803308188915, 0.15640245378017426, 0.12905903160572052, 0.09920094907283783, };
const TfArray<1, int> tensor_dimension3 = { 1, { 8 } };
const ALIGN(8) float tensor_data4[3] = { 0.05450250580906868, -0.029863150790333748, -0.019986448809504509, };
const TfArray<1, int> tensor_dimension4 = { 1, { 3 } };
const ALIGN(8) float tensor_data5[3*24] = { 
  -0.32613000273704529, -0.63786697387695312, -0.65612691640853882, 0.44768351316452026, 0.093391939997673035, 0.11525428295135498, 0.35592800378799438, 0.13757029175758362, -0.51703929901123047, -0.27546361088752747, -0.35472667217254639, 0.44143646955490112, 0.075066298246383667, 0.58107298612594604, 0.6234128475189209, -0.11526493728160858, -0.44942390918731689, -0.026060143485665321, -0.59805852174758911, -0.24595654010772705, -0.22563575208187103, 0.31575524806976318, 0.57000565528869629, 0.53664886951446533, 
  0.44191673398017883, -0.14284496009349823, 0.25546801090240479, -0.29346200823783875, 0.13493290543556213, 0.15787108242511749, -0.19349050521850586, 0.30927664041519165, 0.42372041940689087, -0.034180201590061188, -0.45378786325454712, 0.17272756993770599, 0.40937891602516174, 0.31395378708839417, -0.44540882110595703, 0.2647826075553894, -0.34975183010101318, 0.279837965965271, -0.021605385467410088, 0.34864875674247742, 0.12507306039333344, 0.41316857933998108, -0.44270169734954834, -0.40172648429870605, 
  -0.51183998584747314, 0.13954809308052063, 0.24253334105014801, 0.1488175243139267, 0.39382255077362061, -0.14117695391178131, -0.2123851478099823, -0.15628224611282349, 0.10888151824474335, -0.029215069487690926, 0.2823825478553772, -0.65600341558456421, -0.33465000987052917, -0.63763850927352905, -0.21612846851348877, -0.4383082389831543, -0.37790292501449585, 0.6336333155632019, 0.61850005388259888, -0.23296241462230682, 0.57966572046279907, -0.5790783166885376, -0.47271448373794556, -0.18579266965389252, 
};
const TfArray<2, int> tensor_dimension5 = { 2, { 3,24 } };
const ALIGN(8) float tensor_data6[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
const TfArray<1, int> tensor_dimension6 = { 1, { 16 } };
const ALIGN(8) float tensor_data7[16*1*3*3] = { 
  /* [0][0][][] */ -0.23771071434020996,-0.24082958698272705,0.21806511282920837, 0.080616816878318787,0.13985228538513184,-0.066780582070350647, -0.051116243004798889,-0.16440831124782562,-0.11662434786558151, 
  /* [1][0][][] */ 0.21596981585025787,0.022191066294908524,0.0039387610740959644, 0.2359297126531601,0.13962866365909576,0.030511219054460526, 0.49016070365905762,0.11442712694406509,-0.061415355652570724, 
  /* [2][0][][] */ -0.0023803114891052246,-0.21622654795646667,-0.31916302442550659, -0.30503621697425842,-0.11622241139411926,-0.00046813488006591797, 0.19327571988105774,-0.10989375412464142,0.10325559973716736, 
  /* [3][0][][] */ -0.22155264019966125,0.09442882239818573,0.3277079164981842, 0.10941124707460403,0.16167213022708893,0.080546930432319641, 0.19070802628993988,0.51531225442886353,0.077269352972507477, 
  /* [4][0][][] */ -0.17998810112476349,-0.45207053422927856,0.44185072183609009, -0.15543714165687561,-0.54296517372131348,0.24889633059501648, -0.18294697999954224,-0.23297165334224701,0.19374150037765503, 
  /* [5][0][][] */ 0.3627980649471283,0.26872467994689941,-0.015932751819491386, 0.10822685807943344,0.353554368019104,-0.040141023695468903, 0.50303179025650024,0.061418041586875916,0.12388540804386139, 
  /* [6][0][][] */ -0.11492146551609039,-0.40921637415885925,0.076356261968612671, 0.43248316645622253,-0.40201130509376526,0.011809342540800571, 0.18555781245231628,-0.03973563015460968,0.2990882396697998, 
  /* [7][0][][] */ -0.10666711628437042,-0.086512431502342224,0.14625996351242065, -0.099162623286247253,-0.057046830654144287,-0.2638779878616333, 0.093554198741912842,-0.009983062744140625,-0.19346994161605835, 
  /* [8][0][][] */ 0.23481176793575287,0.075720682740211487,-0.018955670297145844, 0.32759445905685425,-0.28685659170150757,0.37349092960357666, 0.44056433439254761,-0.37381666898727417,0.13932237029075623, 
  /* [9][0][][] */ 0.16685523092746735,0.0052776890806853771,-0.023600276559591293, -0.11830060184001923,0.40733498334884644,-0.26227018237113953, 0.3058619499206543,0.39674893021583557,0.069784171879291534, 
  /* [10][0][][] */ -0.21583974361419678,0.098612457513809204,-0.069483406841754913, 0.22035346925258636,-0.34512922167778015,0.48729798197746277, 0.18813681602478027,-0.45444920659065247,0.18601220846176147, 
  /* [11][0][][] */ 0.35085079073905945,0.38607785105705261,-0.29146826267242432, 0.30550608038902283,0.18384353816509247,-0.0029387548565864563, 0.36303931474685669,-0.16543884575366974,-0.057600118219852448, 
  /* [12][0][][] */ 0.26816520094871521,0.064697302877902985,-0.24303683638572693, 0.18592515587806702,-0.011249702423810959,0.19703896343708038, 0.25613105297088623,-0.35104593634605408,-0.31017765402793884, 
  /* [13][0][][] */ 0.035036981105804443,0.06187102198600769,-0.060266882181167603, -0.12195660173892975,-0.27477559447288513,0.041651219129562378, -0.014853507280349731,0.078076153993606567,0.26309463381767273, 
  /* [14][0][][] */ -0.21912427246570587,-0.2950156033039093,-0.05923888087272644, 0.21777549386024475,0.43952807784080505,0.15109783411026001, -0.025352666154503822,0.25342664122581482,-0.068377554416656494, 
  /* [15][0][][] */ -0.036165181547403336,0.26090124249458313,-0.2488572895526886, 0.29274681210517883,0.22495777904987335,-0.11656272411346436, 0.47425675392150879,0.11987181752920151,0.011743901297450066, 
};
const TfArray<4, int> tensor_dimension7 = { 4, { 16,1,3,3 } };
const ALIGN(8) float tensor_data8[8] = { 0, 0, 0, 0, 0, 0, 0, 0, };
const TfArray<1, int> tensor_dimension8 = { 1, { 8 } };
const ALIGN(8) float tensor_data9[8*1*3*16] = { 
  /* [0][0][][] */ -0.21585053205490112,-0.021817196160554886,-0.085765749216079712,-0.28726774454116821,-0.3900475800037384,0.26678070425987244,0.32279658317565918,-0.077151402831077576,0.051173415035009384,-0.21484775841236115,-0.074109598994255066,0.019377496093511581,0.42658194899559021,0.013858973979949951,-0.24855117499828339,0.27108246088027954, 0.21262812614440918,0.13698472082614899,-0.043301090598106384,-0.29762187600135803,-0.51977384090423584,-0.17275151610374451,0.060576926916837692,0.26969426870346069,0.039977282285690308,0.066272459924221039,-0.12704752385616302,0.13182233273983002,0.28149530291557312,0.16522377729415894,-0.23634839057922363,0.15142431855201721, 0.16694611310958862,0.16533112525939941,-0.17369721829891205,-0.4348565936088562,-0.062703914940357208,0.16187553107738495,0.34861099720001221,-0.25904589891433716,0.22221226990222931,-0.17386119067668915,0.34147694706916809,-0.10716485977172852,0.39256054162979126,0.25007683038711548,-0.23606352508068085,0.085979960858821869, 
  /* [1][0][][] */ -0.11574410647153854,0.16704054176807404,0.24883908033370972,-0.0037985749077051878,-0.43470406532287598,0.27804791927337646,-0.028035860508680344,-0.044981464743614197,0.19707195460796356,0.44156792759895325,0.0051558469422161579,0.39365515112876892,0.36371847987174988,-0.28527900576591492,0.26697438955307007,0.13493150472640991, -0.19278591871261597,0.22871661186218262,-0.14031100273132324,0.49609404802322388,-0.35440313816070557,0.47469231486320496,-0.0039939577691257,-0.23874084651470184,-0.031276308000087738,0.34114158153533936,0.041647717356681824,0.29190501570701599,0.12899024784564972,0.26027041673660278,0.068670704960823059,0.044685058295726776, 0.16292968392372131,0.013638891279697418,0.24309378862380981,0.18572916090488434,-0.16483193635940552,0.43520835041999817,0.18621651828289032,0.038167268037796021,0.25183150172233582,0.26999440789222717,-0.21748197078704834,0.13215196132659912,-9.3597598606720567e-05,0.1325342059135437,0.29348567128181458,0.27093568444252014, 
  /* [2][0][][] */ -0.15064549446105957,0.14597763121128082,0.17987877130508423,0.26014077663421631,-0.36207842826843262,0.37408971786499023,-0.2849804162979126,-0.0088175833225250244,0.12752662599086761,0.20566847920417786,0.056535050272941589,-0.10186201333999634,-0.033335857093334198,-0.13436371088027954,-0.054406523704528809,0.28342786431312561, 0.28513211011886597,0.51303374767303467,-0.018425911664962769,0.2818591296672821,-0.26254564523696899,0.23554037511348724,0.16624355316162109,0.10084763169288635,0.19062575697898865,0.4935411810874939,-0.13089233636856079,0.27354371547698975,-0.026524536311626434,0.2654460072517395,0.32746660709381104,-0.039533380419015884, -0.07661263644695282,0.233732670545578,-0.21756914258003235,0.18196707963943481,-0.33356869220733643,0.16192743182182312,-0.30852910876274109,-0.27062681317329407,0.13252167403697968,0.10531065613031387,-0.0097352322190999985,0.075811468064785004,0.27535635232925415,0.26115113496780396,0.30316969752311707,0.082719847559928894, 
  /* [3][0][][] */ -0.19880110025405884,0.032139964401721954,0.088918030261993408,-0.28479978442192078,0.14122609794139862,-0.13941210508346558,0.23388588428497314,0.16451907157897949,0.068523675203323364,-0.20788812637329102,0.46970599889755249,-0.2392534613609314,-0.0096519859507679939,0.17769894003868103,0.22856612503528595,-0.10257302224636078, -0.051972132176160812,-0.080311261117458344,-0.062218129634857178,0.25475391745567322,0.24759086966514587,0.092613808810710907,0.39726075530052185,-0.11508327722549438,0.28586995601654053,-0.14178295433521271,0.29941678047180176,-0.068544760346412659,0.14650605618953705,0.041164129972457886,0.12062174081802368,0.19797903299331665, 0.0062142610549926758,-0.046501636505126953,-0.25856038928031921,0.11935517936944962,0.39899292588233948,-0.30203491449356079,0.1105010136961937,0.22134596109390259,-0.10677105933427811,0.22247679531574249,0.268393874168396,-0.30325812101364136,0.053558327257633209,0.22372454404830933,-0.011609907262027264,-0.026638943701982498, 
  /* [4][0][][] */ 0.091393910348415375,0.31409463286399841,0.07933613657951355,-0.0054450621828436852,-0.058695472776889801,-0.27364981174468994,0.13522391021251678,-0.074811413884162903,0.2164502888917923,0.062336888164281845,-0.069647245109081268,0.20353935658931732,0.015195395797491074,0.1145491898059845,0.29574844241142273,-0.25176018476486206, -0.19115830957889557,0.10262610018253326,-0.045585483312606812,0.073422156274318695,-0.21485856175422668,0.31013655662536621,0.047126967459917068,-0.0035444498062133789,-0.047720253467559814,0.1921297162771225,-0.05802411213517189,-0.1634126603603363,0.25005170702934265,0.17468720674514771,0.42092552781105042,0.14769403636455536, 0.25264191627502441,0.032728392630815506,-0.23374782502651215,-0.082876965403556824,0.07798285037279129,-0.20960845053195953,0.43985146284103394,-0.15144862234592438,-0.076487511396408081,-0.20006059110164642,0.30619984865188599,0.10820843279361725,-0.18870684504508972,0.016023337841033936,0.0060675549320876598,0.1046401634812355, 
  /* [5][0][][] */ 0.20884735882282257,0.058893755078315735,-0.13979247212409973,-0.055010102689266205,-0.046506162732839584,-0.13988935947418213,0.36224022507667542,0.19367101788520813,0.41546431183815002,-0.28302466869354248,0.50573933124542236,-0.13434404134750366,0.22354553639888763,-0.054496660828590393,0.19868795573711395,-0.20365513861179352, -0.16083690524101257,-0.10148923099040985,-0.22469609975814819,-0.23309046030044556,-0.015771737322211266,0.030501764267683029,0.36226806044578552,-0.092156395316123962,0.34043574333190918,0.045170918107032776,0.46817877888679504,0.010830480605363846,-0.081120997667312622,-0.23968739807605743,-0.28420591354370117,-0.22488218545913696, -0.082854285836219788,-0.051182456314563751,0.013974249362945557,-0.41885632276535034,0.34336960315704346,-0.16134770214557648,0.23622900247573853,0.15400975942611694,0.3935178816318512,-0.12577319145202637,0.25251954793930054,0.080328129231929779,-0.12614764273166656,0.19165104627609253,-0.031410045921802521,-0.15873552858829498, 
  /* [6][0][][] */ 0.17582376301288605,-0.21071489155292511,0.067012786865234375,-0.065829738974571228,0.39483177661895752,-0.0095354598015546799,0.30143037438392639,0.1162472665309906,0.039560426026582718,-0.48786389827728271,0.29811194539070129,0.13268417119979858,-0.34150674939155579,-0.1542624831199646,0.12497143447399139,-0.43929556012153625, 0.075214594602584839,-0.1479400098323822,0.0026406943798065186,0.0046422146260738373,0.3708508312702179,-0.42917636036872864,-0.11308444291353226,0.034653991460800171,-0.0067123179323971272,0.00080749019980430603,0.43891212344169617,-0.16555619239807129,-0.22776830196380615,-0.013342797756195068,-0.34919819235801697,-0.29183581471443176, -0.14594690501689911,-0.35461670160293579,0.21789723634719849,0.13088415563106537,0.25285744667053223,-0.0016399765154346824,-0.014009859412908554,-0.19650125503540039,0.12845541536808014,-0.25782844424247742,-0.025115916505455971,0.00043293705675750971,-0.19272731244564056,0.013963252305984497,-0.10625831037759781,-0.17404308915138245, 
  /* [7][0][][] */ -0.17302995920181274,0.090397760272026062,-0.16835477948188782,-0.026630062609910965,0.44094452261924744,-0.18053326010704041,0.09500402957201004,0.17646923661231995,-0.12965868413448334,-0.31368845701217651,0.43673998117446899,-0.36546275019645691,0.12748065590858459,-0.21455788612365723,0.029077908024191856,-0.15776869654655457, 0.077953055500984192,-0.23879443109035492,-0.23962098360061646,-0.12856756150722504,0.027675250545144081,-0.16866621375083923,0.1863410621881485,-0.23782119154930115,0.33545666933059692,0.023991094902157784,0.37492731213569641,0.097668997943401337,0.12636971473693848,0.26604247093200684,-0.43274280428886414,-0.10598822683095932, -0.25874510407447815,0.35873150825500488,-0.24299563467502594,-0.38391077518463135,-0.44352653622627258,0.082955509424209595,0.25368699431419373,-0.22960872948169708,0.31897023320198059,-0.21155133843421936,0.25194528698921204,0.10495735704898834,-0.0022996428888291121,-0.17860421538352966,-0.039805192500352859,0.048301812261343002, 
};
const TfArray<4, int> tensor_dimension9 = { 4, { 8,1,3,16 } };
const ALIGN(8) int32_t tensor_data10[4] = { 1, 1, 10, 3, };
const TfArray<1, int> tensor_dimension10 = { 1, { 4 } };
const ALIGN(8) int32_t tensor_data11[3] = { 1, 10, 16, };
const TfArray<1, int> tensor_dimension11 = { 1, { 3 } };
const ALIGN(8) int32_t tensor_data12[4] = { 1, 10, 1, 16, };
const TfArray<1, int> tensor_dimension12 = { 1, { 4 } };
const ALIGN(8) int32_t tensor_data13[4] = { 1, 1, 5, 16, };
const TfArray<1, int> tensor_dimension13 = { 1, { 4 } };
const ALIGN(8) int32_t tensor_data14[3] = { 1, 5, 8, };
const TfArray<1, int> tensor_dimension14 = { 1, { 3 } };
const ALIGN(8) int32_t tensor_data15[4] = { 1, 5, 1, 8, };
const TfArray<1, int> tensor_dimension15 = { 1, { 4 } };
const TfArray<4, int> tensor_dimension16 = { 4, { 1,1,10,3 } };
const TfArray<4, int> tensor_dimension17 = { 4, { 1,1,10,16 } };
const TfArray<3, int> tensor_dimension18 = { 3, { 1,10,16 } };
const TfArray<3, int> tensor_dimension19 = { 3, { 1,10,16 } };
const TfArray<4, int> tensor_dimension20 = { 4, { 1,10,1,16 } };
const TfArray<4, int> tensor_dimension21 = { 4, { 1,5,1,16 } };
const TfArray<4, int> tensor_dimension22 = { 4, { 1,1,5,16 } };
const TfArray<4, int> tensor_dimension23 = { 4, { 1,1,5,8 } };
const TfArray<3, int> tensor_dimension24 = { 3, { 1,5,8 } };
const TfArray<3, int> tensor_dimension25 = { 3, { 1,5,8 } };
const TfArray<4, int> tensor_dimension26 = { 4, { 1,5,1,8 } };
const TfArray<4, int> tensor_dimension27 = { 4, { 1,3,1,8 } };
const TfArray<2, int> tensor_dimension28 = { 2, { 1,24 } };
const TfArray<2, int> tensor_dimension29 = { 2, { 1,3 } };
const TfArray<2, int> tensor_dimension30 = { 2, { 1,3 } };
const TfLiteReshapeParams opdata0 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs0 = { 2, { 0,10 } };
const TfArray<1, int> outputs0 = { 1, { 16 } };
const TfLiteConvParams opdata1 = { kTfLitePaddingSame, 1,1, kTfLiteActNone, 1,1 };
const TfArray<3, int> inputs1 = { 3, { 16,7,6 } };
const TfArray<1, int> outputs1 = { 1, { 17 } };
const TfLiteReshapeParams opdata2 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs2 = { 2, { 17,11 } };
const TfArray<1, int> outputs2 = { 1, { 18 } };
const TfLiteAddParams opdata3 = { kTfLiteActRelu };
const TfArray<2, int> inputs3 = { 2, { 18,2 } };
const TfArray<1, int> outputs3 = { 1, { 19 } };
const TfLiteReshapeParams opdata4 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs4 = { 2, { 19,12 } };
const TfArray<1, int> outputs4 = { 1, { 20 } };
const TfLitePoolParams opdata5 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs5 = { 1, { 20 } };
const TfArray<1, int> outputs5 = { 1, { 21 } };
const TfLiteReshapeParams opdata6 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs6 = { 2, { 21,13 } };
const TfArray<1, int> outputs6 = { 1, { 22 } };
const TfLiteConvParams opdata7 = { kTfLitePaddingSame, 1,1, kTfLiteActNone, 1,1 };
const TfArray<3, int> inputs7 = { 3, { 22,9,8 } };
const TfArray<1, int> outputs7 = { 1, { 23 } };
const TfLiteReshapeParams opdata8 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs8 = { 2, { 23,14 } };
const TfArray<1, int> outputs8 = { 1, { 24 } };
const TfLiteAddParams opdata9 = { kTfLiteActRelu };
const TfArray<2, int> inputs9 = { 2, { 24,3 } };
const TfArray<1, int> outputs9 = { 1, { 25 } };
const TfLiteReshapeParams opdata10 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs10 = { 2, { 25,15 } };
const TfArray<1, int> outputs10 = { 1, { 26 } };
const TfLitePoolParams opdata11 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs11 = { 1, { 26 } };
const TfArray<1, int> outputs11 = { 1, { 27 } };
const TfLiteReshapeParams opdata12 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs12 = { 2, { 27,1 } };
const TfArray<1, int> outputs12 = { 1, { 28 } };
const TfLiteFullyConnectedParams opdata13 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs13 = { 3, { 28,5,4 } };
const TfArray<1, int> outputs13 = { 1, { 29 } };
const TfLiteSoftmaxParams opdata14 = { 1 };
const TfArray<1, int> inputs14 = { 1, { 29 } };
const TfArray<1, int> outputs14 = { 1, { 30 } };
const TensorInfo_t tensorData[] = {
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 128, (TfLiteIntArray*)&tensor_dimension0, 120, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data1, (TfLiteIntArray*)&tensor_dimension1, 8, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data2, (TfLiteIntArray*)&tensor_dimension2, 64, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data3, (TfLiteIntArray*)&tensor_dimension3, 32, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data4, (TfLiteIntArray*)&tensor_dimension4, 12, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data5, (TfLiteIntArray*)&tensor_dimension5, 288, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data6, (TfLiteIntArray*)&tensor_dimension6, 64, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data7, (TfLiteIntArray*)&tensor_dimension7, 576, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data8, (TfLiteIntArray*)&tensor_dimension8, 32, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data9, (TfLiteIntArray*)&tensor_dimension9, 1536, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data10, (TfLiteIntArray*)&tensor_dimension10, 16, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data11, (TfLiteIntArray*)&tensor_dimension11, 12, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data12, (TfLiteIntArray*)&tensor_dimension12, 16, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data13, (TfLiteIntArray*)&tensor_dimension13, 16, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data14, (TfLiteIntArray*)&tensor_dimension14, 12, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data15, (TfLiteIntArray*)&tensor_dimension15, 16, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension16, 120, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 640, (TfLiteIntArray*)&tensor_dimension17, 640, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension18, 640, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 640, (TfLiteIntArray*)&tensor_dimension19, 640, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension20, 640, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 640, (TfLiteIntArray*)&tensor_dimension21, 320, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension22, 320, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 320, (TfLiteIntArray*)&tensor_dimension23, 160, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension24, 160, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 160, (TfLiteIntArray*)&tensor_dimension25, 160, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension26, 160, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 160, (TfLiteIntArray*)&tensor_dimension27, 96, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension28, 96, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 96, (TfLiteIntArray*)&tensor_dimension29, 12, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension30, 12, },
};const NodeInfo_t nodeData[] = {
  { (TfLiteIntArray*)&inputs0, (TfLiteIntArray*)&outputs0, const_cast<void*>(static_cast<const void*>(&opdata0)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs1, (TfLiteIntArray*)&outputs1, const_cast<void*>(static_cast<const void*>(&opdata1)), OP_CONV_2D, },
  { (TfLiteIntArray*)&inputs2, (TfLiteIntArray*)&outputs2, const_cast<void*>(static_cast<const void*>(&opdata2)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs3, (TfLiteIntArray*)&outputs3, const_cast<void*>(static_cast<const void*>(&opdata3)), OP_ADD, },
  { (TfLiteIntArray*)&inputs4, (TfLiteIntArray*)&outputs4, const_cast<void*>(static_cast<const void*>(&opdata4)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs5, (TfLiteIntArray*)&outputs5, const_cast<void*>(static_cast<const void*>(&opdata5)), OP_MAX_POOL_2D, },
  { (TfLiteIntArray*)&inputs6, (TfLiteIntArray*)&outputs6, const_cast<void*>(static_cast<const void*>(&opdata6)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs7, (TfLiteIntArray*)&outputs7, const_cast<void*>(static_cast<const void*>(&opdata7)), OP_CONV_2D, },
  { (TfLiteIntArray*)&inputs8, (TfLiteIntArray*)&outputs8, const_cast<void*>(static_cast<const void*>(&opdata8)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs9, (TfLiteIntArray*)&outputs9, const_cast<void*>(static_cast<const void*>(&opdata9)), OP_ADD, },
  { (TfLiteIntArray*)&inputs10, (TfLiteIntArray*)&outputs10, const_cast<void*>(static_cast<const void*>(&opdata10)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs11, (TfLiteIntArray*)&outputs11, const_cast<void*>(static_cast<const void*>(&opdata11)), OP_MAX_POOL_2D, },
  { (TfLiteIntArray*)&inputs12, (TfLiteIntArray*)&outputs12, const_cast<void*>(static_cast<const void*>(&opdata12)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs13, (TfLiteIntArray*)&outputs13, const_cast<void*>(static_cast<const void*>(&opdata13)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs14, (TfLiteIntArray*)&outputs14, const_cast<void*>(static_cast<const void*>(&opdata14)), OP_SOFTMAX, },
};
static std::vector<void*> overflow_buffers;
static TfLiteStatus AllocatePersistentBuffer(struct TfLiteContext* ctx,
                                                 size_t bytes, void** ptr) {
  if (current_location - bytes < tensor_boundary) {
    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    *ptr = malloc(bytes);
    if (*ptr == NULL) {
      printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return kTfLiteError;
    }
    overflow_buffers.push_back(*ptr);
    return kTfLiteOk;
  }

  current_location -= bytes;

  *ptr = current_location;
  return kTfLiteOk;
}
typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;
static std::vector<scratch_buffer_t> scratch_buffers;

static TfLiteStatus RequestScratchBufferInArena(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  scratch_buffer_t b;
  b.bytes = bytes;

  TfLiteStatus s = AllocatePersistentBuffer(ctx, b.bytes, &b.ptr);
  if (s != kTfLiteOk) {
    return s;
  }

  scratch_buffers.push_back(b);

  *buffer_idx = scratch_buffers.size() - 1;

  return kTfLiteOk;
}

static void* GetScratchBuffer(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > static_cast<int>(scratch_buffers.size()) - 1) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}
} // namespace

  TfLiteStatus trained_model_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;
  ctx.AllocatePersistentBuffer = &AllocatePersistentBuffer;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArena;
  ctx.GetScratchBuffer = &GetScratchBuffer;
  ctx.tensors = tflTensors;
  ctx.tensors_size = 31;
  for(size_t i = 0; i < 31; ++i) {
    tflTensors[i].type = tensorData[i].type;
    tflTensors[i].is_variable = 0;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
    tflTensors[i].allocation_type = tensorData[i].allocation_type;
#else
    tflTensors[i].allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
    tflTensors[i].bytes = tensorData[i].bytes;
    tflTensors[i].dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
    if(tflTensors[i].allocation_type == kTfLiteArenaRw){
      uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

     tflTensors[i].data.data =  start;
    }
    else{
       tflTensors[i].data.data = tensorData[i].data;
    }
#else
    tflTensors[i].data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
    tflTensors[i].quantization.type = kTfLiteNoQuantization;
    if (tflTensors[i].allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tflTensors[i].data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }
  if (tensor_boundary > current_location /* end of arena size */) {
    printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }
  registrations[OP_RESHAPE] = *tflite::ops::micro::Register_RESHAPE();
  registrations[OP_CONV_2D] = *tflite::ops::micro::Register_CONV_2D();
  registrations[OP_ADD] = *tflite::ops::micro::Register_ADD();
  registrations[OP_MAX_POOL_2D] = *tflite::ops::micro::Register_MAX_POOL_2D();
  registrations[OP_FULLY_CONNECTED] = *tflite::ops::micro::Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = *tflite::ops::micro::Register_SOFTMAX();

  for(size_t i = 0; i < 15; ++i) {
    tflNodes[i].inputs = nodeData[i].inputs;
    tflNodes[i].outputs = nodeData[i].outputs;
    tflNodes[i].builtin_data = nodeData[i].builtin_data;
    tflNodes[i].custom_initial_data = nullptr;
    tflNodes[i].custom_initial_data_size = 0;
    if (registrations[nodeData[i].used_op_index].init) {
      tflNodes[i].user_data = registrations[nodeData[i].used_op_index].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
    }
  }
  for(size_t i = 0; i < 15; ++i) {
    if (registrations[nodeData[i].used_op_index].prepare) {
      TfLiteStatus status = registrations[nodeData[i].used_op_index].prepare(&ctx, &tflNodes[i]);
      if (status != kTfLiteOk) {
        return status;
      }
    }
  }
  return kTfLiteOk;
}

static const int inTensorIndices[] = {
  0, 
};
TfLiteTensor* trained_model_input(int index) {
  return &ctx.tensors[inTensorIndices[index]];
}

static const int outTensorIndices[] = {
  30, 
};
TfLiteTensor* trained_model_output(int index) {
  return &ctx.tensors[outTensorIndices[index]];
}

TfLiteStatus trained_model_invoke() {
  for(size_t i = 0; i < 15; ++i) {
    TfLiteStatus status = registrations[nodeData[i].used_op_index].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus trained_model_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif
  scratch_buffers.clear();
  for (size_t ix = 0; ix < overflow_buffers.size(); ix++) {
    free(overflow_buffers[ix]);
  }
  overflow_buffers.clear();
  return kTfLiteOk;
}
